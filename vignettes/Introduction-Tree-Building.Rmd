---
title: "Introduction to Tree Building with splinetree"
author: "Anna Neufeld"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This guide is meant for users who are familiar with regression trees and the spline projection method but who are unfamiliar with the ``splinetree`` package specifics. For more information about the spline projection method, see *Introduction to splinetree*. The guide walks through examples of building a tree, plotting a tree, and evaluating a tree. The data used for these examples comes from the National Longitudinal Survey of Youth (1979). In the example, we are studying the relationship between baseline socioeconomic variables (measured during teenage years) and body mass index (BMI) trajectories throughout adulthood. We are looking for socioeconomic factors that may drive heterogeneity in BMI trajectories. 

# Building and Visualizing Trees 

To begin building a tree, all that is needed is a longitudinal dataset (should be in long format) and the specification of four different types of variables. After establishing the dataset and specifying the variables, there are numerous ways to customize the tree so as to best fit the data (including controlling the tree size and customizing the spline basis matrix). 

## Specifying variables and building default tree

We are working with the ``nlsySample`` dataset, which is already in long format. Building a ``splinetree`` object requires a call to the ``splineTree`` function. The ``splineTree`` function has four parameters that do not have default values. These are ``tformula``, ``splitformula``, ``idvar``, and ``data``. We must identify the following variables in the dataset.
1. **Response variable**: The longitudinal response variable. In our example, this is ``BMI``. 
2. **Time variable**: Together with the response variable, the time variable allows us to specify the ``tformula`` parameter. The ``tformula`` parameter defines the trajectory we are interested in. In our case, the time variable is ``AGE`` and the ``tformula`` is ``BMI~AGE``. 
3. ***Split variables**: The variables that the tree will make splits on. These variables should be *time constant*- for a given individual (ID), each split variable should only take on one value. These are variables that we think might influence the trajectory of the reponse over time. In our example, these are the baseline socioeconomic variables selected from the NLSY. Together with the response variable, the split variables are used to specify the ``splitformula`` parameter. 
4. **ID variable**: The variable used to identify individual observations that belong to the same trajectory individual. In our example, this is ``ID``. The name of this variable gets provided to the ``splineTree()`` function as a string. 

The code below shows a subset of rows and columns of ``nlsySample``. 


In selecting split variables, we are able to use ``HGC_MOTHER`` (highest grade completed by mother), ``HGC_FATHER`` (highest grade completed by father), ``Num_sibs``, and ``RACE``, because each of these are baseline variables that were recorded once at the first subject interview  and did not change over time. However, ``HGC`` (highest grade completed by survey participant) cannot be used as a split variable because the responses for a given individual change as individuals complete more schooling. If we wished to include the highest grade completed by an individual as a split variable, we would need to summarize the variable in some way to create a new, time constant variable. For example, for each ID, we could find the maximum value that HGC takes on, and form a new variable with this maximum. In other instances, we could summarize a time-varying covariate using a mean or through regression over the time variable in order to capture some information about the time-varying covariate in the splitting process. In our example, we will not do this. 

```{r, include=FALSE}
library(splinetree)
```

```{r, echo=FALSE}
head(nlsySample[,c(1,26,31, 12,14,17,24,27)], n=20)
```

Taking into account the additional time-constant variables in ``nlsySample``, we are ready to specify our first several parameters for our call to ``splineTree()``. 

```{r}
split_formula <- BMI ~ HISP + WHITE + BLACK + SEX + Dad_Full_Work + Mom_Full_Work   + Age_first_weed + Age_first_smoke + Age_first_alc + Num_sibs + 
  HGC_FATHER + HGC_MOTHER + Mag + News + Lib + Two_Adults_14 + 
  Mother_14 + Father_14 + STABLE_RESIDENCE + URBAN_14 + South_Birth
tformula <- BMI~AGE
idvar <- "ID"
data <-nlsySample
```

Since all remaining parameters have default parameters, we are ready to  to build our first tree. 

```{r}
first_tree <- splineTree(split_formula, tformula, idvar, data)
```

## Viewing and visualizing the default tree

We can view our tree either through printing with ``stPrint`` or plotting with ``stPlot``.  

```{r}
stPrint(first_tree)
```

By default, this tree was built with a cubic spline basis with no internal knots and no intercept. This gives the tree 3 degrees of freedom (df = degree + number of internal knots + intercet). That is why each node is described by three coefficients. These three coefficients, together with information about the spline basis, describe the trajectory that is predicted for each node. This tree is very small, and so it is relatively straightforward to see that 

```{r}
stPlot(first_tree)
```


 



If we want to see information about each node but we don't want it printed in tree format, we can use ``treeSummary()``.
```{r}
treeSummary(first_tree)
```

## Controlling Tree Size

Our first tree is very small. 

We notice that our tree is very small. This is due to the default value of the *complexity parameter* (``cp``). The *complexity parameter* is passed by ``splinetree`` into the call to ``rpart`` and specifies a minimum improvement in ndoe purity that must occur in order for the tree to make a split. The default cp value of 0.01 typically helps prevent overly large trees, but in the NLSY example the relationships are quite weak, and so in order to build a tree that will be interesting to plot we might want to lower the cp. We also notice that in this first tree, one of our terminal nodes has only 16 people in it, as it only includes individuals with 12 or more siblings. So our tree is basically showing us the population average trajectory, and then it is showing us that individuals with 12 or more siblings tend to gain weight more rapidly than individuals with less than 12 siblings. While this is interesting, it applies to a very small subset of the population. We might want to only let our tree build terminal nodes with say, at least 20 people in them. We can do this with the ``minNodeSize`` parameter. Let's modify our tree:

```{r}
second_tree <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.001)
treeSize(second_tree)
```

When we lower the ``cp`` to 0.001, the tree has 25 terminal nodes. This tree will be difficult to plot or analyze. Let's try an in-between ``cp`` of 0.005. 

```{r}
third_tree <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.005)
treeSize(third_tree)  
stPrint(third_tree)
stPlot(third_tree)
```

6 terminal nodes seems like a reaosnable tree size for this example. The tree is small enough to plot and understand, but large enough to be interesting. If we want, we can zoom in on different nodes in our plot using the ``plotNode`` function. For example, suppose we want more detail on the node labeled as node 8 in our tree prinout. 

```{r}
plotNode(third_tree, 8)
```

If we want all of the data associated with node 4, we can use:

```{r}
node8dat <- getNodeData(third_tree, 8)
```

We might wish to remind ourselves whick datapoints fall in node 4. We can do this with:

```{r}
terminalNodeSummary(third_tree, 8)
```

This reminds us that node 4 contains all dataponts where HGC_MOTHER < 9.5 and Num_sibs < 8.5 and Age_first_smoke < 14.5. Let's just confirm that everything is working as we think it is:

```{r}
range(node8dat$Num_sibs)
range(node8dat$HGC_MOTHER, na.rm=TRUE)
range(node8dat$Age_first_smoke)
```

We could similarly obtain summaries or data subsets of any other terminal nodes. 

## Customizing Spline Basis Matrix 

Now that we have seen how to work with a basic tree, we can start thinking about how we might customize our tree to better fit our data. By default, this tree was built using a cubic spline basis with no internal knots and with no intercept. In order to build the best possible tree for our data / research question, we should think about modifying these choices. 

To learn more about how the spline basis matrix is used in the splitting process, see the longer *Package Introduction* Vignette. In the splitting process, each individual's observations are projected down onto a piecewise polynomial basis. In order to 


There is generally no "right" or "wrong" answer for choosing the spline basis for your tree. But there are a few guiding principles that might help you make a decision. 

1) **Use prior knowledge** 
In our example, we will fit a few different trees with different values of these parameters for the sake of comparison. Previous research has found that, on average, adult BMIs tend to increase steadily throughout early adulthood and then flatten out in later adulthood (Clarke et al. 2008). This type of trajectory could be modeled either with a quadratic trajectory or a piecewise linear trajectory, so either of these might be a good choice for our tree. We will build both down below. 
2) **Limit degrees of freedom**
- Although choosing a higher degree and more internal knots or degrees of freedom will allow each projected trajectory to more truly capture the real trajectory, allowing the basis matrix to have too many dimensions can cause problems. If an individual has less observations than the specified degrees of freedom, then during the projection process they will be assigned NA coefficients and their data will be thrown out by rpart during the splitting process.
- Word of caution about data on all sides of internal knots. 
- Because prior knowledge tells us that linear of quadratic are appropriate, wont bother to use anything more complex, because more complex might be bad. 


NEED TO TALK ABOUT DEGREE, Knots, and DF. But while we are here might as well talk about gridPoints and nGrid too. 

SHOW ONE EXAMPLE 

```{r}
linear_tree <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.005, degree=1, df=2)
quadratic_tree <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.005, degree=2) 
```


```{r}
treeSize(linear_tree)
treeSize(quadratic_tree)
stPrint(linear_tree)
stPrint(quadratic_tree)
```

The tree sizes have changed slightly even with the same ``cp``, but they are still reasonably sized for working with. One thing we notice with more nodes is that the plot colors can start to look too similar- that is why it can be nice to use your own colors. 

```{r}
colors = c("red", "purple", "blue", "pink", "cyan", "green", "grey", "yellow", "white", "magenta", "cornflowerblue")
stPlot(linear_tree, colors)
stPlot(quadratic_tree, colors)
```

## Intercept or No Intercept

One final parameter to talk about-- it's important!!!
Note that now we have to say DF=3
One major difference- Sex now appears in both trees. Maybe that means that Sex effects level but not shape of trajectory. Seems reasonable, and shows why we learn by considering both intercept and no intercept trees side by side. So when we move into evaluating trees, we will keep considering both. 


```{r}
linear_tree_intercept <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.005, degree=1, df=3, intercept=TRUE)
quadratic_tree_intercept <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.005, degree=2, intercept=TRUE)
stPlot(linear_tree_intercept, colors)
stPlot(quadratic_tree_intercept, colors)
```


# Evaluating Trees

So now that we have four different trees- two intercept and two no intercept - how are we supposed to know which is "correct" or "better"? 
Comparing intercept and no intercept is like comparing apples and oranges, so we don't really care about that. 
What we care about is, between quad/linear, which is better? 

let's start with the intercept trees. Intercept is special because we can actually do predicton

```{r}
R2_y(linear_tree_intercept)
R2_y(quadratic_tree_intercept)
```




Hmm, so these two tress are pretty comparable in amount of variation they explain. Overall, even if they don't really look alike, they are similar trees. Just to note, we COULD drive up R2 a bunch with a big tree, but we would be overfitting so don't do this.Similar, we might expect to do worse with a linear tree with no knots, because we know that the real trajectories don't really look like this. 

```{r}
big_tree <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.0001, degree=3, df=5, intercept=TRUE)
R2_y(big_tree)
simple_tree <- splineTree(split_formula, tformula, idvar, data, minNodeSize=20, cp=0.005, degree=1, df=1, intercept=TRUE)
R2_y(simple_tree)
```

Okay, what if for this intercept tree we want to know how well we are capturing the shape. Well, there is no "true" shape, but we can look at how well we capture the projected shape. 

```{r}
R2_projected(linear_tree_intercept)
R2_projected(quadratic_tree_intercept)
R2_projected(big_tree)
```

FIRST NOTE- low numbers. MOST variation that CAN be explained is explained by age. We have weak relationships.

```{r}
R2_projected(linear_tree_intercept, includeIntercept=TRUE)
R2_projected(quadratic_tree_intercept, includeIntercept=TRUE)
```

IMPORTANT NOTE- big tree much better at projections, but not that much better at actually predicting Y. Getting better and better at trajcetory is not always good. 


The nice thing about R2_projected is that, while not perfect, it can be used for intercept or no intercept trees alike. 

So now we should basically understand how to build, visualize and evaluate single trees. To learn more details about the package algorithm, see the longer package Introduction vignette. If you would like to move on to Package quickstart 2- for forests. 



