<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction to splinetree • splinetree</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Introduction to splinetree">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">splinetree</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.2.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Forest-Intro.html">Forest Building with splinetree</a>
    </li>
    <li>
      <a href="../articles/Long-Intro.html">Introduction to splinetree</a>
    </li>
    <li>
      <a href="../articles/Tree-Intro.html">Tree Building with splinetree</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/anna-neufeld/splinetree">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Introduction to splinetree</h1>
            
            <h4 class="date">2019-07-16</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/anna-neufeld/splinetree/blob/master/vignettes/Long-Intro.Rmd"><code>vignettes/Long-Intro.Rmd</code></a></small>
      <div class="hidden name"><code>Long-Intro.Rmd</code></div>

    </div>

    
    
<p>This vignette describes the motivation for the <code>splinetree</code> package and introduces the algorithms used by the package. For a more practical guide to working with data using the functionalities of the <code>splinetree</code> package, see the vignettes <em>Tree Building with splinetree</em> and <em>Forest Building with splinetree</em>.</p>
<div id="motivation" class="section level1">
<h1 class="hasAnchor">
<a href="#motivation" class="anchor"></a>Motivation</h1>
<p>Longitudinal studies, where an outcome of interest is repeatedly measured in the same subjects over time, play a key role in research across a variety of disciplines, including medicine, epidemiology, and the social sciences. In these studies, the trajectory of a longitudinal outcome over time can look very different in different members of the population. It is often useful to find factors that help explain this variation in growth patterns. We propose using longitudinal regression trees, specifically <code>splinetree,</code> to find population subgroups where group members follow similar longitudinal trajectory patterns and share common baseline covariate values. We also propose using spline forests to understand which baseline covariates can explain the most variation in trajectories.</p>
<p>Regression trees, which recursively partition a population into homogenous subgroups (nodes), are a promising approach to this problem, but many regression tree algorithms cannot be used for studying longitudinal trajectories. Longitudinal regression trees were first proposed by <span class="citation">Segal (1992)</span>, who suggested minimizing within-node Mahalanobis distance of longitudinal response vectors. This method requires that all individuals in the sample have the same number of equally spaced measurements of the outcome, which is rarely the case in studies involving human subjects. <span class="citation">Yu and Lambert (1999)</span> eliminated this need for balanced data by first reducing the dimension of the outcome vector using smoothing splines and then maximizing within-node homogeneity of the smoothed trajectories. The work of Yu and Lambert is the basis for the algorithm employed by <code>splinetree</code>.</p>
</div>
<div id="algorithm" class="section level1">
<h1 class="hasAnchor">
<a href="#algorithm" class="anchor"></a>Algorithm</h1>
<p>The method for building a <code>splinetree</code> model, which is invoked with every call to the function <code>splineTree(),</code> consists of two steps. First, the longitudinal response vector for each individual in the dataset is projected onto a spline basis, yielding a set of coefficients for each individual. Second, the coefficients from the projection are used in constructing a regression tree that maximizes the within-node homogeneity of the projected trajectories.</p>
<div id="spline-projection" class="section level2">
<h2 class="hasAnchor">
<a href="#spline-projection" class="anchor"></a>Spline Projection</h2>
<p>Yu and Lambert suggested treating each response vector as a functional curve <span class="math display">\[Y_i(t) = f_i(t) + \epsilon_i(t)\]</span> where <span class="math inline">\(f_i(t) = \sum_{k = 1}^q\beta_{ik} X_k(t)\)</span> for a set of basis functions, <span class="math inline">\(X_k(t)\)</span> and coefficient vector <span class="math inline">\(\boldsymbol{\beta}_i = (\beta_{i1},...,\beta_{iq})^T\)</span>, and where <span class="math inline">\(\epsilon_i(t)\)</span> is a white noise process with mean zero and constant variance. The first step of <code><a href="../reference/splineTree.html">splineTree()</a></code> transforms the user-provided longitudinal dataset (in long format) into a wide format dataset where each individual is defined by their coefficient vector <span class="math inline">\(\boldsymbol{\hat{\beta}}_i = (\hat{\beta}_{i1},...,\hat{\beta}_{iq})^T\)</span>. In the final regression tree, terminal nodes are labeled with average coefficient vectors <span class="math inline">\(\boldsymbol{\bar{\beta}} = (\bar{\beta}_{1},...,\bar{\beta}_{q})^T\)</span> over the individuals in the node. These average coefficients, along with the tree-wide basis functions <span class="math inline">\(X_k(t)\)</span>, describe the average trajectory for individuals whose covariate values place them in this node.</p>
<p>The <code>splinetree</code> package uses B-Splines (built using <code><a href="https://www.rdocumentation.org/packages/splines/topics/bs">splines::bs()</a></code>), rather than smoothing splines as originally suggested in Yu and Lambert, for the basis functions <span class="math inline">\(X_k(t)\)</span> and obtains the coefficients by regressing each individual’s longitudinal response on these common basis functions. Whereas the original dataset may have a irregular number of observations per individual, the transformed dataset is balanced; each individual has the same number of estimated coefficients, all of which correspond to a common set of basis functions.</p>
<p>A consequence of flattening the data in this way is that baseline covariates used for splitting the tree cannot be time-varying. When <code><a href="../reference/splineTree.html">splineTree()</a></code> is called it expects a dataset in long format where the baseline covariates it can split on take on the same value in every row corresponding to a certain individual. In order to include information about time-varying covariates in the tree, summary measured can be defined and included as split variables. For example, instead of including time-varying yearly income as a split variable, we could define a new time-constant variable for each individual such as starting income, average income, or average yearly increase in income. Alternatively, if income is a non-linear, one could smooth those variables with a spline basis and use the coefficients as split variables (at the expense of interpretability).</p>
<p>One unique feature of the <code><a href="../reference/splineTree.html">splineTree()</a></code> function is that the user can specify whether or not the set of basis functions <span class="math inline">\(X_k(t)\)</span> includes the intercept function. This allows the user to explore relationships with shape, separate from level. When the intercept is included, the splits of the tree take into account both the shape and the level of the longitudinal response trajectory, and the terminal nodes of the tree describe full trajectories that can be used for prediction. When the intercept is excluded, the splits of the tree take into account only the shape of the trajectories. In this case, the predicted coefficients for terminal nodes describe trajectories that are equal to <span class="math inline">\(0\)</span> when <span class="math inline">\(t=0\)</span>, which will typically not provide reasonable prediction values. To obtain rough predictions from intercept-less trajectories, the mean starting response for all individuals in the node can be added onto the trajectory after the fact as an estimated intercept.</p>
<p>The set of basis functions <span class="math inline">\(X_1(t), ..., X_q(t)\)</span> is determined by parameters to the <code><a href="../reference/splineTree.html">splineTree()</a></code> function which are passed forward to the <code>bs()</code> function. The <code>degree</code> parameter, with default equal to 3 for a cubic spline, specifies the degree of the polynomials for the spline basis. The boundary knots for the spline basis are set to be the minimum and maximum values that the time variable takes on in the dataset, and no internal knots are included in the spline basis as a default. In order to accomodate more complex trajectory patterns, a vector of internal knot locations can be provided through the <code>knots</code> parameter. Alternatively, internal knots can be added using the <code>df</code> parameter. If provided, the <code>df</code> parameter sets <code>q</code> (the number of basis functions), and so the number of internal knots is set to be <code>df-degree-intercept.</code> In this case, the appropriate number of knots are placed automatically at percentiles of the time variable to break up the data into equally size groups. The parameters <code>knots</code> and <code>df</code> should not be simultaneously provided; one or the other should be used to add internal knots.</p>
<p>The tree-building process seeks to maximize homogeneity of smoothed trajectories within nodes; if the projected trajectories poorly approximate the real data, the tree will not be useful. Therefore, the choice of parameters such as <code>degree</code> and <code>df</code> should be guided by knowledge of the trajectories being modeled. If the trajectories are suspected to be non-monotonic, a linear basis with no knots is a poor choice. Although more complex bases allow the individual projections to more closely model the individual response vectors, overly complex bases should be avoided. If the number of coefficients (<span class="math inline">\(q\)</span>) exceeds the number of observations for a certain individual, the individual will be assigned <code>NA</code> coefficient values and this individual will be ignored during the tree-building process. To avoid throwing out data, <span class="math inline">\(q\)</span> should be less than the minimum number of observations per individual. Even an individual with many observations may be assigned <code>NA</code> coefficients if they have no observations to one side of an internal knot. Individuals with only one observation to one side of an internal knot can be assigned extremely large coefficients that affect the tree-building process. For these reasons, before choosing a basis it is important to ensure that individuals in the dataset have enough observations to justify the spine basis, and that these observations are spread out enough to support the placement of internal knots.</p>
</div>
<div id="split-criteria" class="section level2">
<h2 class="hasAnchor">
<a href="#split-criteria" class="anchor"></a>Split Criteria</h2>
<p>Once the data has been transformed into a matrix of spline coefficients, a regression tree is built. The tree building process employed by <code>splinetree</code> uses the same exhaustive search algortihm as CART, from <span class="citation">Brieman et al. (1984)</span>, but with a modified measure of node purity. CART is implemented in the popular <code>rpart</code> package (<span class="citation">T. Therneau and Atkinson (2018)</span>). The <code>splinetree</code> package is built on top of <code>rpart</code> using the custom split function framework explained in <span class="citation">T. M. Therneau (2018)</span>, and so a <code>splinetree</code> model is actually an object of class <code>rpart.</code></p>
<p>As in CART, at each node the <code>splinetree</code> algorithm computes a split score for all possible ways to separate the data based on the split covariates. The score is based entirely off of the smoothed response curves described by the spline coefficients; the actual response data is never seen by the split function. The split score is based on the reduction in the sum of squared errors of the smoothed trajectories in the node around the mean smoothed trajectory in the node. The errors are evaluated at a set of fixed grid points. If <span class="math inline">\(N\)</span> denotes the data found in the current node, <span class="math inline">\(L\)</span> denots the data found to the left of the split, and <span class="math inline">\(R\)</span> denotes the data to the right of the split, the split score is <span class="math inline">\(SS_N - SS_L - SS_R\)</span>. The value <span class="math inline">\(SS_S\)</span> for a set <span class="math inline">\(S\)</span> is defined as</p>
<p><span class="math display">\[ SS_S = \sum_{i \in S}(\mathbf{X}\hat{\boldsymbol \beta}_{i}  - \mathbf{X}\bar{\boldsymbol{\beta}}_{S} )^T(\mathbf{X}\boldsymbol{\beta}_{i}  - \mathbf{X}\bar{\boldsymbol{\beta}}_S )= \sum_{i \in S}(\boldsymbol \beta_{i} - \bar{\boldsymbol{\beta}}_{S} )^T\mathbf{X}^T\mathbf{X}(\boldsymbol{\beta}_{i} \ - \bar{\boldsymbol{\beta}}_{S})\]</span></p>
<p>where the matrix <span class="math inline">\(\mathbf{X}\)</span> contains the values of the basis functions <span class="math inline">\(X_1(t), ..., X_k(t)\)</span> evaluated at the chosen fixed time points on a grid <span class="math inline">\((t_1,...,t_m)\)</span>, the <span class="math inline">\(\hat{\boldsymbol{\beta}}_i\)</span> are the spline coefficients for individual <span class="math inline">\(i\)</span>, and <span class="math inline">\(\bar{\boldsymbol{\beta}}_S\)</span> is the mean coefficient vector for all individuals in set <span class="math inline">\(S\)</span>. The grid points can be specified using the parameter <code>nGrid</code>, which specifies the number of grid points to be placed automatically at percentiles of the time variable, or the parameter <code>gridPoints</code>, which provides a vector of specific time points.</p>
<p>At the end of the exhaustive search, the split with the highest split score (meaning that it provides the largest decrease in the projection sum of squared errors) is selected as the split for the current node. The process is then repeated recursively. For computational efficiency, not every possible partition of categories is considered for a categorical variable. The cateogries are first placed into an approximate order based on the magnitude of the average coefficients of data belonging to each category, and then only binary splits along the ordering are considered.</p>
<p>Apart from the custom split score, other behavior of the tree building process mimics that of <code>rpart</code>. For example, missing covariate values are handled with surrogate splits (see the <code>rpart</code> documentaiton for more details). The size of a <code>splinetree</code> can be controlled with the complexity parameter, <code>cp</code>, which is passed forward to <code>rpart</code>. A large splinetree can also be pruned with the <code><a href="https://www.rdocumentation.org/packages/rpart/topics/prune.rpart">rpart::prune()</a></code> method. Since the <code>rpart</code> tree is built using a flattened version of the original data, the rows of an <code>rpart</code>-created attribute such as <code>tree$where</code> will correspond to the rows of the flattened data, not the original data. For users who are familiar with the <code>rpart</code> package and wish to use features such as <code>tree$where</code>, the flattened dataset that indexes the <code>tree$where</code> vector can be found in <code>tree$parms$flat_data.</code></p>
<p>Although a <code>splinetree</code> model is an <code>rpart</code> object, not all <code>rpart</code> functions will have the expected behavior when applied to a <code>splinetree</code> model. Numerous <code>splinetree</code> functions have been provided to make the models easier to work with. For example, <code>print.rpart()</code> will not print out the full vector of predicted coefficients for each node of a <code>splinetree</code> model, and so the <code><a href="../reference/stPrint.html">splinetree::stPrint()</a></code> method is preferable. Similarly, <code>predict.rpart()</code> will fail to return the full vector of coefficients associated with a node, and so <code><a href="../reference/predictCoeffs.html">splinetree::predictCoeffs()</a></code> is preferable.</p>
</div>
</div>
<div id="example" class="section level1">
<h1 class="hasAnchor">
<a href="#example" class="anchor"></a>Example</h1>
<p>In this section, we will show how to use <code><a href="../reference/splineTree.html">splineTree()</a></code> to build a tree. More details on customizing, visualizing, and evaluating <code>splinetree</code> models can be found in the vignette <em>Tree Building with splinetree</em>.</p>
<p>This example uses data taken from the National Longitudinal Survey of Youth, 1979 (NLSY). The longitudinal trajectory of interest is body mass index (BMI) over time. We randomly sample 1,000 individuals from the NLSY out of those who have non-missing BMI data at at least 10 timepoints spread out over at least 20 years. We are interested in the relationship between BMI trajectories and time-constant variables such as HISP, WHITE, BLACK (indicator variables for subject’s reported race), SEX (indicator for subject’s reported sex), Num_sibs (number of siblings), and HGC_FATHER and HGC_MOTHER (reported highest grade completed by subject’s father and subject’s mother).</p>
<p>Previous research by <span class="citation">Clarke et al. (2008)</span> suggests that adult BMIs tend to increase steadily throughout early adulthood and flatten out in later adulthood. This type of trajectory can be modeled with a piecewise linear trajectory, so we will define our spline basis with <code>degree = 1</code> and one internal knot. Since we do not have a particular location in mind for the internal knot, we use the <code>df</code> parameter rather than the <code>knots</code> parameter. This will place the knot at the median age. If we include an intercept, we will need to let <code>df = 3</code> to add one internal knot, but if we do not include an intercept <code>df = 2</code> will suffice. In this example, we build one tree with an intercept and one tree without an intercept so as to compare the two. The default value in the <code>rpart</code> package for the <code>cp</code> parameter, which controls the size of the tree, is 0.01. Here, we set the value of <code>cp</code> slightly lower to create trees that are large enough to be interesting but small enough to view in a plot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/library">library</a></span>(splinetree)
## Loading required package: rpart
## Loading required package: nlme
## Loading required package: splines</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">split_formula &lt;-<span class="st"> </span><span class="er">~</span>HISP +<span class="st"> </span>WHITE +<span class="st"> </span>BLACK +<span class="st"> </span>SEX +<span class="st"> </span>Num_sibs +<span class="st"> </span>HGC_FATHER +<span class="st"> </span>HGC_MOTHER
tformula &lt;-<span class="st"> </span>BMI ~<span class="st"> </span>AGE
sample_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, <span class="dt">idvar =</span> <span class="st">"ID"</span>, 
                          <span class="dt">data =</span> nlsySample, <span class="dt">degree =</span> <span class="dv">1</span>, <span class="dt">df =</span> <span class="dv">2</span>, 
                          <span class="dt">intercept =</span> <span class="ot">FALSE</span>, <span class="dt">cp =</span> <span class="fl">0.005</span>)
sample_tree_intercept &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, <span class="dt">idvar =</span> <span class="st">"ID"</span>, 
                                    <span class="dt">data =</span> nlsySample, <span class="dt">degree =</span> <span class="dv">1</span>, <span class="dt">df =</span> <span class="dv">3</span>, 
                                    <span class="dt">intercept =</span> <span class="ot">TRUE</span>, <span class="dt">cp =</span> <span class="fl">0.005</span>)</code></pre></div>
<p>After building these two trees, we can view a printed summary or a plot of each. Beginning with the no-intercept tree, we see that non-white individuals are predicted to have more rapid growth in body mass index than white individuals. Among white individuals, those whose fathers did not complete more than 8.5 years of schooling show more rapid BMI growth. Since this tree was built without an intercept, the average starting BMI is added to each average trajectory in the plot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/stPrint.html">stPrint</a></span>(sample_tree)
## n= 1000,  
## 
## node), split, n , coefficients 
##       * denotes terminal node
## 
## 1) root, 1000,  (4.961796, 8.091247) 
##   2) WHITE&lt; 0.5, 505,  (5.882807, 9.006190)*
##   3) WHITE&gt;=0.5, 495,  (4.022179, 7.157821) 
##     6) HGC_FATHER&lt; 8.5, 78,  (5.198284, 8.642817)*
##     7) HGC_FATHER&gt;=8.5, 417,  (3.802188, 6.880053)*
<span class="kw"><a href="../reference/stPlot.html">stPlot</a></span>(sample_tree)</code></pre></div>
<p><img src="Long-Intro_files/figure-html/unnamed-chunk-3-1.png" width="672"></p>
<p>In the tree that is built with an intercept, each node is associated with three coefficients instead of two. While we see two of the same variables that were in the no-intercept tree included here, we now also see sex playing a role. This suggests that sex may impact the level of BMI but not the shape of the trajectory.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/stPrint.html">stPrint</a></span>(sample_tree_intercept)
## n= 1000,  
## 
## node), split, n , coefficients 
##       * denotes terminal node
## 
##  1) root, 1000,  (21.52416, 4.961796, 8.091247) 
##    2) WHITE&lt; 0.5, 505,  (21.42300, 5.882807, 9.006190) 
##      4) HGC_FATHER&lt; 0.5, 25,  (23.08928, 7.703289, 8.380706)*
##      5) HGC_FATHER&gt;=0.5, 480,  (21.33622, 5.787990, 9.038767)*
##    3) WHITE&gt;=0.5, 495,  (21.62736, 4.022179, 7.157821) 
##      6) SEX&lt; 1.5, 259,  (22.69360, 3.999510, 6.896897)*
##      7) SEX&gt;=1.5, 236,  (20.45721, 4.047057, 7.444175) 
##       14) HGC_FATHER&lt; 7.5, 12,  (20.40041, 9.027571, 9.903029)*
##       15) HGC_FATHER&gt;=7.5, 224,  (20.46025, 3.780243, 7.312451)*
<span class="kw"><a href="../reference/stPlot.html">stPlot</a></span>(sample_tree_intercept, <span class="dt">colors=</span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="st">"red"</span>, <span class="st">"orange"</span>, <span class="st">"yellow"</span>, <span class="st">"blue"</span>, <span class="st">"cyan"</span>))</code></pre></div>
<p><img src="Long-Intro_files/figure-html/unnamed-chunk-4-1.png" width="672"></p>
</div>
<div id="forests" class="section level1">
<h1 class="hasAnchor">
<a href="#forests" class="anchor"></a>Forests</h1>
<p>The examples above suggest that the variables <code>WHITE</code> and <code>HGC_FATHER</code> are most associated with the shape of a BMI trajectory, and that these same variables, with the addition of <code>SEX</code>, are associated with the BMI level. However, a single regression tree gives a poor overview of the true importance of covariates. If there is a close tie between the “goodness” of two possible splits at the top level of the tree, then a new tree built to a slightly perturbed dataset could include an entirely different set of covariates. If two covariates that are associated with the trajectories are highly correlated, it is likely that only one will appear in the tree.</p>
<p>The <code>rpart</code> package has a built in variable importance metric based on improvements of goodness of fit provided by both split varaibles and surrogate split variables (see the <code>rpart</code> documentation for more information). While this measure helps capture the importance of second-best or correlated covariates that do not appear in the tree itself, this measure can show bias towards variables with more unique values; a very important binary variable that is used at the top level of a tree is not available for surrogate splits later in the tree, and so its importance according to this metric may be smaller than a less important numeric variable that is repeatedly used as a surrogate split throughout the tree. A consequence of this bias is that the <code>rpart</code> variable importance rankings are highly dependent on the size that a tree is pruned to; in larger trees, variables with many unique values can appear over and over again as primary or surrogate splits, which inflates their importance. This bias is illustrated in the plot below, which displays the <code>rpart</code> variable importance metric for the <code>sample_intercept_tree</code> from above along with an identical tree that is allowed to grow much larger. While <code>SEX</code> is rated to be the most important variable in the small tree, when the tree is allowed to grow larger the importance of all three non-binary variables surpasses the importance of <code>SEX</code>. This is an example of a general trend; as trees grow larger, the <code>rpart</code> importance of variables with many unique values is inflated relative to variables with fewer unique values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">extra_large_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, BMI ~<span class="st"> </span>AGE, <span class="st">"ID"</span>, nlsySample, <span class="dt">degree =</span> <span class="dv">1</span>, <span class="dt">df =</span> <span class="dv">2</span>, <span class="dt">intercept =</span> <span class="ot">TRUE</span>, <span class="dt">cp =</span> <span class="fl">0.0005</span>)
vars =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/attr">attr</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/terms">terms</a></span>(split_formula), <span class="st">"term.labels"</span>)
imp_large=extra_large_tree$variable.importance
imp_small=sample_tree_intercept$variable.importance</code></pre></div>
<p><img src="Long-Intro_files/figure-html/unnamed-chunk-7-1.png" width="672"></p>
<p>In the univariate setting, Random Forests and the associated permutation importance measure are popular ways to obtain more stable measures of variable importance (see <span class="citation">Breiman (2001)</span> or <span class="citation">Liaw and Wiener (2002)</span> for more). Through random data subsampling and random variable selection, Random Forests give variables that are not locally optimal in a single tree a chance to appear in a tree. The <code><a href="../reference/splineForest.html">splineForest()</a></code> method allows users to build ensembles of spline trees, combining the projection splitting framework of <code><a href="../reference/splineTree.html">splineTree()</a></code> with the random subsampling and random variable selection principles of a Random Forest.</p>
<div id="spline-forest-implementation" class="section level2">
<h2 class="hasAnchor">
<a href="#spline-forest-implementation" class="anchor"></a>Spline Forest Implementation</h2>
<p>Once a user is familiar with the <code><a href="../reference/splineTree.html">splineTree()</a></code> function, using the <code><a href="../reference/splineForest.html">splineForest()</a></code> function is straightforward; most of the parameters are identical. Although a spline forest is an ensemble of spline trees, a call to <code><a href="../reference/splineForest.html">splineForest()</a></code> does not involve repeated calls to <code><a href="../reference/splineTree.html">splineTree()</a></code>. The projection process happens only once in a forest, and the random subsampling occurs on the level of the flattened data, not the individual responses. This ensures that full trajectories are kept together in the forest building process. Following the work of <span class="citation">Strobl et al. (2007)</span>, we perform random subsampling without replacement, and we subsample 63.5% of the data for each tree (this matches the proportion of data that we would expect to be used for each tree if we used the more traditional practice of bootstrap sampling). <span class="citation">Strobl et al. (2007)</span> show that sampling without replacement reduces bias in the permutation importance metric when compared to bootstrap sampling. By setting the parameter <code>bootstrap=TRUE</code>, users can choose to use bootstrap sampling instead.</p>
<p>The <code>ntree</code> parameter specifies the number of trees in the ensemble; <code>ntree</code> random samples are drawn from the flattened data and a tree is built to each of these samples. Each tree uses the same split criteria as the <code><a href="../reference/splineTree.html">splineTree()</a></code> function but incorporates a random component into the split selection. The <code>prob</code> parameter determines the probability that any one variable is put into contention to be the split variable at a node. An appropriate value for the <code>prob</code> parameter depends on the number of total split variables. If there are only three total split variables and <code>prob = 1/2</code>, then there is a <span class="math inline">\(1/8\)</span> chance that no variables will be considered for a split and the tree building will terminate prematurely. However, with a large number of split variables, a probability of around <span class="math inline">\(1/3\)</span> is appropriate. This method for incorporating random variable selection is different than the method implemented in the <code>randomForest</code> package (<span class="citation">Liaw and Wiener (2002)</span>), where the number of variables to be considered at each node is specified, not left up to chance. The choice to use a probability arose from the desire to stay within the <code>rpart</code> custom-split framework; the probability version could be easily implemented without modifying the base <code>rpart</code> code.</p>
</div>
<div id="example-1" class="section level2">
<h2 class="hasAnchor">
<a href="#example-1" class="anchor"></a>Example</h2>
<p>We build an example spline forest using the same dataset introduced above, using a linear spline basis with one internal knot and an intercept.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">forest &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineForest.html">splineForest</a></span>(split_formula, tformula, <span class="dt">idvar =</span> <span class="st">"ID"</span>, <span class="dt">data =</span> nlsySample, <span class="dt">degree =</span> <span class="dv">1</span>, <span class="dt">df =</span> <span class="dv">3</span>, <span class="dt">intercept =</span> <span class="ot">TRUE</span>,<span class="dt">ntree =</span> <span class="dv">50</span>, <span class="dt">prob =</span> <span class="fl">0.5</span>, <span class="dt">cp =</span> <span class="fl">0.005</span>)</code></pre></div>
<p>This model returned by this function is a named list with 15 components. The individual trees in the forest are saved in <code>forest$Trees</code>. Looking at <code>forest$Trees[[1]]</code>, we see that, due to the bootsrapping and the randomization, new variables appear that did not appear in a single tree.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/stPrint.html">stPrint</a></span>(forest$Trees[[<span class="dv">1</span>]])
## n= 632,  
## 
## node), split, n , coefficients 
##       * denotes terminal node
## 
##  1) root, 632,  (21.64528, 4.787193,  8.000699) 
##    2) HGC_MOTHER&lt; 9.5, 166,  (21.65323, 6.015235,  9.129890) 
##      4) HGC_FATHER&lt; 11.5, 140,  (21.61799, 6.331730,  9.582940) 
##        8) BLACK&lt; 0.5, 100,  (21.50187, 5.808061,  9.268297) 
##         16) HISP&lt; 0.5, 33,  (21.72981, 4.495059,  8.801145)*
##         17) HISP&gt;=0.5, 67,  (21.38961, 6.454764,  9.498386) 
##           34) HGC_FATHER&lt; 7.5, 44,  (20.61722, 5.810081,  8.481129)*
##           35) HGC_FATHER&gt;=7.5, 23,  (22.86721, 7.688072, 11.444440)*
##        9) BLACK&gt;=0.5, 40,  (21.90828, 7.640900, 10.369550)*
##      5) HGC_FATHER&gt;=11.5, 26,  (21.84300, 4.311033,  6.690391)*
##    3) HGC_MOTHER&gt;=9.5, 466,  (21.64245, 4.349736,  7.598456) 
##      6) BLACK&lt; 0.5, 323,  (21.69656, 4.028888,  7.059810)*
##      7) BLACK&gt;=0.5, 143,  (21.52024, 5.074447,  8.815116)*</code></pre></div>
<p>While each tree within <code>forest$Trees</code> is an <code>rpart</code> object that can be printed with <code>stPrint</code>, these trees are not the same as <code>splinetree</code> model. A single <code>splinetree</code> tree stores information about the spline basis used and the flattened dataset within it. For the sake of eliminating redundancy in already large <code>splineforest</code> models, this information is not stored in every tree in a forest; it is only saved once at the forest level (see, for example, <code>forest$innerKnots</code> and <code>forest$flat_data</code>). Many <code>splinetree</code> functions, including <code><a href="../reference/stPlot.html">stPlot()</a></code>, expect this additional information to be stored at the tree level, and therefore <code><a href="../reference/stPlot.html">stPlot(forest$Trees[[1]])</a></code> will result in an error.</p>
<p>To determine which data points were used in the making of the first tree in the forest, we can use <code>forest$index[[1]]</code>. The indices found in this vector refer to rows of <code>forest$flat_data</code>. It is important to know which data points were used in the making of each tree because this can determine the predictions from the forest. In obtaining predicted responses for a datapoint that was in the training sample, we can average the predictions from each individual tree in the dataset, or we can only average predictions across trees in the forest for which this datapoint was “out-of-the-bag,” meaning that it was not in the boostrap sample. “Out-of-the-bag”" (or “oob”) predictions are suggested by <span class="citation">Breiman (2001)</span> because they provide a sense of out-of-sample performance of the forest without using a distinct test set. In the <code>splinetree</code> package, we can predict BMIs for each individual in the NLSY sample either using “all” trees for each datapoint, only trees for which this datapoint was “out of the bag,” or only trees for which this datapoint was “in the bag” (or “itb”).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fullpreds &lt;-<span class="st"> </span><span class="kw"><a href="../reference/predictYForest.html">predictYForest</a></span>(forest, <span class="dt">method =</span> <span class="st">"all"</span>)
oobpreds &lt;-<span class="st"> </span><span class="kw"><a href="../reference/predictYForest.html">predictYForest</a></span>(forest, <span class="dt">method =</span> <span class="st">"oob"</span>)
itbpreds &lt;-<span class="st"> </span><span class="kw"><a href="../reference/predictYForest.html">predictYForest</a></span>(forest, <span class="dt">method =</span> <span class="st">"itb"</span>)</code></pre></div>
<p>If we look at these predictions, we see that the “oob” prediction errors are greater, but this lower performance is more representative of how our forest might perform on a new test set.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/cor">cor</a></span>(fullpreds, nlsySample$BMI)
## [1] 0.4581262
<span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/cor">cor</a></span>(itbpreds, nlsySample$BMI)
## [1] 0.4906948
<span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/cor">cor</a></span>(oobpreds, nlsySample$BMI)
## [1] 0.3976721</code></pre></div>
</div>
<div id="variable-importance" class="section level2">
<h2 class="hasAnchor">
<a href="#variable-importance" class="anchor"></a>Variable Importance</h2>
<p>Our key motivation in building a spline forest was to figure out which variables are most importantly associated with heterogeneity in BMI trajectory. The <code>splinetree</code> package implements a variable importance metric closely related to that of <span class="citation">Breiman (2001)</span> and <span class="citation">Liaw and Wiener (2002)</span>.</p>
<p>For every tree in the forest, tree performance is measured on out-of-the-bag data points. Then, the values of variable <span class="math inline">\(V\)</span> are randomly permuted, and tree performance is re-measured. The average difference in performance over all trees in forest becomes the variable importance score for variable <span class="math inline">\(V\)</span>. The <code>splinetree</code> package provides scores using the absolute difference in performance, the percent difference in importance, and the standardized difference in importance (differences divided by their standard deviation). In most cases, these three metrics will rank the variables in the same way, and so the choice is a matter of preference. A variable importance score reported as negative should be interpreted as a variable importance score of <span class="math inline">\(0\)</span>.</p>
<p>Two different definitions of tree “performance” can be used. If the forest’s spline basis includes the intercept, variable importace can be measured with respect to predicting the response outcome. In this case, the tree performance metric used is the Mean Squared Prediction Error (MSE), as in <span class="citation">Liaw and Wiener (2002)</span>. This version is implemented in the function <code><a href="../reference/varImpY.html">varImpY()</a></code>.</p>
<p>Alternatively, we can measure tree performance using the projection sum of squared errors. The advantage of this metric is that it can be used whether or not the forest includes an intercept. When used on a non-intercept forest, it measures the importance of each variable in determining the shape of a trajectory. When used on a forest with an intercept, there is an option to ignore the intercept in the variable importance calculations. Therefore, even though the sample forest we have been working with includes an intercept, we can still calculate a measure of shape-based variable importance.</p>
<p>We can create three different variable importance matrices using our sample forest. We can then compare the response-based importance to the projection-based importances (both including and ignoring the intercept). Each of these importance matrix contains three columns, corresponding to absolute differences in performance, percent differences in performance, and standardized differences in importance. We will use the third column.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Y_imps &lt;-<span class="st"> </span><span class="kw"><a href="../reference/varImpY.html">varImpY</a></span>(forest) <span class="co">#on the slow side</span>
coeff_imps &lt;-<span class="st"> </span><span class="kw"><a href="../reference/varImpCoeff.html">varImpCoeff</a></span>(forest, <span class="dt">removeIntercept =</span> <span class="ot">FALSE</span>)
shape_imps &lt;-<span class="st"> </span><span class="kw"><a href="../reference/varImpCoeff.html">varImpCoeff</a></span>(forest, <span class="dt">removeIntercept =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/par">par</a></span>(<span class="dt">mfrow =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="dv">1</span>,<span class="dv">3</span>))
<span class="kw"><a href="../reference/plotImp.html">plotImp</a></span>(Y_imps[,<span class="dv">3</span>], <span class="dt">main =</span> <span class="st">"Response"</span>)
<span class="kw"><a href="../reference/plotImp.html">plotImp</a></span>(coeff_imps[,<span class="dv">3</span>], <span class="dt">main =</span><span class="st">"Coeff w/ Intercept"</span>)
<span class="kw"><a href="../reference/plotImp.html">plotImp</a></span>(shape_imps[,<span class="dv">3</span>], <span class="dt">main =</span> <span class="st">"Coeff w/out Intercept"</span>)</code></pre></div>
<p><img src="Long-Intro_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<p>Using a splineForest, some new variables have relatively high importance. For example, while HGC_MOTHER did not appear in a splineTree, it has a similar overall imporance to HGC_FATHER. These two variables may be unlikely to appear in the same tree due to their correlation (0.667 among complete cases), but the permutation importance metric shows that both variables are associated with the level and the shape of the outcome. The first two panels of the graph are quite similar because they both take into account level and shape; the difference is that the first panel looks at how influential the variables are for approximating BMI values, whereas the second panel looks at how influential the variables are for approximating the smoothed BMI trajectories. The fact that the panels look similar is good because it suggests that the smoothed trajectories used are reasonable approximations of true BMI.</p>
<p>The third panel of the graph shows more differences. When the intercept of the smoothed trajectories is ignored, the <code>SEX</code> variable loses all importance. This mirrors the observation from our splineTree, where <code>SEX</code> appeared in the intercept tree but not the no intercept tree. Now that we are using a forest, we can more confidently assert that reported sex is associated with the level of BMI but not the shape of the trajectory over time.</p>
</div>
</div>
<div id="conclusion" class="section level1">
<h1 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h1>
<p>The <code>splinetree</code> package allows users to build regression trees and random forests for longitudinal trajectories. The spline basis method is flexible enough to accomodate complex trajectory shapes, and the models can be used to study just the shape of the trajectories, or to study shape and level simultaneously. For more details on the functionalities of the package, see the vignettes <em>Tree Building with splinetree</em> and <em>Forest Building with splinetree</em>.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-breiman2001random">
<p>Breiman, Leo. 2001. “Random Forests.” <em>Machine Learning</em> 45 (1). Springer: 5–32.</p>
</div>
<div id="ref-brieman1984classification">
<p>Brieman, L, J Friedman, R Olshen, and C Stone. 1984. “Classification and Regression Trees. Belmont (ca): Wadsworth.” <em>Google Scholar</em>.</p>
</div>
<div id="ref-clarke2008social">
<p>Clarke, Philippa, Patrick M O’malley, Lloyd D Johnston, and John E Schulenberg. 2008. “Social Disparities in Bmi Trajectories Across Adulthood by Gender, Race/Ethnicity and Lifetime Socio-Economic Position: 1986–2004.” <em>International Journal of Epidemiology</em> 38 (2). Oxford University Press: 499–509.</p>
</div>
<div id="ref-liaw2002classification">
<p>Liaw, Andy, and Matthew Wiener. 2002. “Classification and Regression by RandomForest.” <em>R News</em> 2 (3): 18–22.</p>
</div>
<div id="ref-segal1992tree">
<p>Segal, Mark Robert. 1992. “Tree-Structured Methods for Longitudinal Data.” <em>Journal of the American Statistical Association</em> 87 (418). Taylor &amp; Francis Group: 407–18.</p>
</div>
<div id="ref-strobl2007bias">
<p>Strobl, Carolin, Anne-Laure Boulesteix, Achim Zeileis, and Torsten Hothorn. 2007. “Bias in Random Forest Variable Importance Measures: Illustrations, Sources and a Solution.” <em>BMC Bioinformatics</em> 8 (1). BioMed Central: 25.</p>
</div>
<div id="ref-therneau2018user">
<p>Therneau, Terry M. 2018. “User Written Splitting Functions for Rpart.” Mayo Clinic URL https://cran.r-project.org/web/packages/rpart/vignettes/usercode.pdf.</p>
</div>
<div id="ref-therneau2018rpart">
<p>Therneau, Terry, and Beth Atkinson. 2018. <em>Rpart: Recursive Partitioning and Regression Trees</em>. <a href="https://CRAN.R-project.org/package=rpart" class="uri">https://CRAN.R-project.org/package=rpart</a>.</p>
</div>
<div id="ref-yu1999fitting">
<p>Yu, Yan, and Diane Lambert. 1999. “Fitting Trees to Functional Data, with an Application to Time-of-Day Patterns.” <em>Journal of Computational and Graphical Statistics</em> 8 (4). Taylor &amp; Francis Group: 749–62.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#motivation">Motivation</a></li>
      <li>
<a href="#algorithm">Algorithm</a><ul class="nav nav-pills nav-stacked">
<li><a href="#spline-projection">Spline Projection</a></li>
      <li><a href="#split-criteria">Split Criteria</a></li>
      </ul>
</li>
      <li><a href="#example">Example</a></li>
      <li>
<a href="#forests">Forests</a><ul class="nav nav-pills nav-stacked">
<li><a href="#spline-forest-implementation">Spline Forest Implementation</a></li>
      <li><a href="#example-1">Example</a></li>
      <li><a href="#variable-importance">Variable Importance</a></li>
      </ul>
</li>
      <li><a href="#conclusion">Conclusion</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Anna Neufeld, Brianna Heggeseth.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
