<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tree Building with splinetree • splinetree</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Tree Building with splinetree">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">splinetree</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Forest-Intro.html">Forest Building with splinetree</a>
    </li>
    <li>
      <a href="../articles/Long-Intro.html">Introduction to splinetree</a>
    </li>
    <li>
      <a href="../articles/Tree-Intro.html">Tree Building with splinetree</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Tree Building with splinetree</h1>
            
            <h4 class="date">2018-08-21</h4>
      
      
      <div class="hidden name"><code>Tree-Intro.Rmd</code></div>

    </div>

    
    
<p>This vignette is meant for users who are familiar with regression trees and the spline projection method but who are unfamiliar with working with <code>splinetree</code> objects. For a more detailed introduction to package and the spline projection method, see the <em>Introduction to splinetree</em> vignette.</p>
<p>This guide walks through examples of building trees, plotting trees, and evaluating trees. The data used for these examples comes from the National Longitudinal Survey of Youth 1979 (NLSY). In this example, we study the relationship between baseline socioeconomic variables (measured during teenage years) and body mass index (BMI) trajectories throughout adulthood. We wish to study the relationship between BMI trajectories and variables such as HISP, WHITE, BLACK (indicator variables for subject’s race), SEX (indicator for subject’s sex), Num_sibs (number of siblings), and HGC_FATHER and HGC_MOTHER (highest grade completed by subject’s father and subject’s mother). We randomly sample 1,000 individuals from the NLSY out of those who have non-missing BMI data at at least 10 timepoints spread out over at least 20 years.</p>
<div id="building-and-visualizing-trees" class="section level1">
<h1 class="hasAnchor">
<a href="#building-and-visualizing-trees" class="anchor"></a>Building and Visualizing Trees</h1>
<div id="building-our-first-tree" class="section level2">
<h2 class="hasAnchor">
<a href="#building-our-first-tree" class="anchor"></a>Building our first tree</h2>
<p>To build a tree, we use the <code><a href="../reference/splineTree.html">splineTree()</a></code> function. There are four parameters to <code>splineTree</code> that do not have default values, and so to get started we need (at a minimum):</p>
<ol style="list-style-type: decimal">
<li><p>A longitudinal dataset, to be supplied via the <code>data</code> parameter. The longitudinal dataset should be in <em>long format</em>, meaning that one row of the data corresponds to one subject at one particular timepoint (in contrast to <em>wide format</em>, where one row of the data corresponds to one subject, and different columns represent responses at different timepoints). Our example dataset, <code>nlsySample</code>, is already in long format.</p></li>
<li><p>A trajectory of interest, to be supplied via the <code>tformula</code> parameter. In our example, the response variable is <code>BMI</code>, and the time variable is <code>AGE</code>, and so the trajectory is defined by the formula <code>BMI~AGE</code>.</p></li>
<li><p>The name of an ID variable, which identifies individual observations that belong to the same trajectory, is supplied as a string via the <code>idvar</code> parameter. In our example, this is “ID”.</p></li>
<li><p>The split formula, to be supplied via the <code>splitformula</code> parameter, which is made up of the response variable and the split variables. All split variables should be <em>time constant</em>, meaning that for a given value of the ID varaible, each split variable takes on only one value. These are variables that we suspect might be related to heterogeneity in trajectories in the population. In our example, these are the baseline socioeconomic variables selected from the NLSY.</p></li>
</ol>
<p>The data subset below illustrates concepts such as long format, ID variable, and time constant split variable in our dataset. In selecting split variables, we can use <code>HGC_MOTHER</code> and <code>HGC_FATHER</code> because these are baseline variables that were recorded once at the first subject interview and did not change over time. However, <code>HGC</code> (highest grade completed by survey participant) cannot be used as a split variable because the responses for a given individual change as individuals complete more schooling. We will omit <code>HGC</code>, but if we wished to include it we could create a new, time-constant variable using the maximum HGC achieved by each ID.</p>
<pre><code>##     ID AGE      BMI HGC_MOTHER HGC_FATHER HGC
## 233 11  21 21.61789         12         12  15
## 234 11  22 21.61789         12         12  16
## 237 11  25 21.61789         12         12  16
## 241 11  30 22.31524         12         12  16
## 242 11  31 22.73365         12         12  16
## 244 11  33 20.92054         12         12  16
## 245 11  34 20.92054         12         12  NA
## 246 11  35 21.61789         12         12  16
## 251 11  45 21.61789         12         12  16
## 302 14  17 20.89355         12         12  11
## 303 14  18 21.66739         12         12  12
## 306 14  21 22.44122         12         12  15
## 307 14  22 23.98889         12         12  16
## 309 14  24 23.21506         12         12  16
## 310 14  25 27.85807         12         12  16
## 311 14  26 27.85807         12         12  16</code></pre>
<p>After identifying these different types of varaibles in <code>nlsySample</code>, we are ready to make our first call to <code><a href="../reference/splineTree.html">splineTree()</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data &lt;-nlsySample
tformula &lt;-<span class="st"> </span>BMI~AGE
idvar &lt;-<span class="st"> "ID"</span>
split_formula &lt;-<span class="st"> </span>BMI ~<span class="st"> </span>HISP +<span class="st"> </span>WHITE +<span class="st"> </span>BLACK +<span class="st"> </span>SEX +<span class="st"> </span>Dad_Full_Work +<span class="st"> </span>Mom_Full_Work   +<span class="st"> </span>Age_first_weed +<span class="st"> </span>Age_first_smoke +<span class="st"> </span>Age_first_alc +<span class="st"> </span>Num_sibs +<span class="st"> </span>HGC_FATHER +<span class="st"> </span>HGC_MOTHER +<span class="st"> </span>Mag +<span class="st"> </span>News +<span class="st"> </span>Lib +<span class="st"> </span>Two_Adults_14 +<span class="st"> </span>Mother_14 +<span class="st"> </span>Father_14 +<span class="st"> </span>STABLE_RESIDENCE +<span class="st"> </span>URBAN_14 +<span class="st"> </span>South_Birth
first_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data)</code></pre></div>
</div>
<div id="viewing-and-visualizing-the-first-tree" class="section level2">
<h2 class="hasAnchor">
<a href="#viewing-and-visualizing-the-first-tree" class="anchor"></a>Viewing and visualizing the first tree</h2>
<p>We can examine our first tree my printing it with <code>stPrint</code> or plotting with <code>stPlot</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/stPrint.html">stPrint</a></span>(first_tree)
## n= 1000,  
## 
## node), split, n , coefficients 
##       * denotes terminal node
## 
## 1) root, 1000,  ( 4.256522, 7.366760,  7.648072) 
##   2) Num_sibs&lt; 11.5, 984,  ( 3.961548, 7.348875,  7.532295) 
##     4) HGC_MOTHER&lt; 9.5, 244,  ( 5.648480, 8.511874,  8.867730)*
##     5) HGC_MOTHER&gt;=9.5, 740,  ( 3.405316, 6.965400,  7.091962)*
##   3) Num_sibs&gt;=11.5, 16,  (22.397410, 8.466678, 14.768350)*</code></pre></div>
<p>Because we used default values for most of the parameters, this tree uses a cubic spline basis with no internal knots and no intercept. This gives the tree 3 degrees of freedom (df = degree + number of internal knots + intercept), and so each node is described by three coefficients. These three coefficients, together with information about the spline basis used, describe the trajectory that is predicted for each node.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/stPlot.html">stPlot</a></span>(first_tree)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
<p>For an alternate view of the trajectories side by side, we can also use the `spaghettiPlot()`` function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/spaghettiPlot.html">spaghettiPlot</a></span>(first_tree)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-6-1.png" width="672"></p>
<p>Because this tree is small, the outputs of <code>stPrint(),</code> <code>stPlot(),</code> and <code><a href="../reference/spaghettiPlot.html">spaghettiPlot()</a></code> are relatively easy to digest. With larger trees, these representations might be harder to look at. In this case, it might be useful to extract information from the trees in other formats. For example, we could extract the coefficients describing each node directly by using</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/treeSummary.html">treeSummary</a></span>(first_tree)
##          var    n       dev  coeffs.1  coeffs.2  coeffs.3
## 1   Num_sibs 1000 262247.50  4.256522  7.366760  7.648072
## 2 HGC_MOTHER  984 242478.92  3.961548  7.348875  7.532295
## 4     &lt;leaf&gt;  244  77137.29  5.648480  8.511874  8.867730
## 5     &lt;leaf&gt;  740 162416.41  3.405316  6.965400  7.091962
## 3     &lt;leaf&gt;   16  13322.94 22.397415  8.466678 14.768348</code></pre></div>
<p>If we are particularly interested in the node labeled as node 4, we can view its coefficients individually:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/treeSummary.html">treeSummary</a></span>(first_tree)[<span class="st">"4"</span>,]$coeffs
##         [,1]     [,2]    [,3]
## [1,] 5.64848 8.511874 8.86773</code></pre></div>
<p>We can also view a summary of node 4, including the path to this node and the coefficients.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/terminalNodeSummary.html">terminalNodeSummary</a></span>(first_tree, <span class="dv">4</span>)
## 
##  node number: 4 
##    root
##    Num_sibs&lt; 11.5
##    HGC_MOTHER&lt; 9.5
## 
##  N: 244
##  Coefficients: 5.64848046155119,8.51187433261078,8.86773033830208</code></pre></div>
<p>Suppose we wanted to work with all of the data that falls into this terminal node. We could filter or subset our dataset to include only observations with <code>Num_sibs &lt; 11.5</code> and <code>HGC_MOTHER &lt; 9.5.</code> A more direct strategy, especially for larger or more complex trees, is to use the <code>getNodeData</code> command. This command will also automatically employ surrogate splits for data that is missing values for <code>Num_sibs</code> or <code>HGC_MOTHER</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">node4dat &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getNodeData.html">getNodeData</a></span>(first_tree, <span class="dv">4</span>)</code></pre></div>
<p>We can confirm that the data found in this <code>node4dat</code> dataframe matches the description of node 4.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">range</span>(node4dat$Num_sibs)
## [1]  0 11
<span class="kw">range</span>(node4dat$HGC_MOTHER, <span class="dt">na.rm=</span><span class="ot">TRUE</span>)
## [1] 0 9</code></pre></div>
<p>Now we know which subset of the data falls into node 4 and we have three coefficients that describe a predicted trajectory for these individuals. However, these coefficients are not useful by themselves. It would be more useful to see a picture of the trajectory that they describe.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plotNode.html">plotNode</a></span>(first_tree, <span class="dt">node=</span><span class="dv">4</span>, <span class="dt">includeData=</span><span class="ot">FALSE</span>, <span class="dt">estimateIntercept=</span><span class="ot">FALSE</span>)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-12-1.png" width="672"></p>
<p>It may seem strange that this plot shows BMI values between 0 and 8, as these are clearly not human BMI values. Since this tree was built without an intercept coefficient, the three coefficients attached to each node describe only the shape of the trajectory- not the starting point. If we want to see a plot with realistic BMI values, we could set the <code>estimateIntercept</code> parameter to <code>TRUE</code>. This will add the average intercept of all individuals in the node back into the trajectory to make the trajectory pass through reasonable BMI values. This is what occurs in the <code><a href="../reference/stPlot.html">stPlot()</a></code> by default.</p>
<p>Before we move on to customizing our tree using additional parameters to <code>splineTree</code>, it is useful to see how we might reproduce the plot above from scratch. It might occasionally be necessary to reconstruct the spline basis matrix for a given tree to turn coefficients into trajectories. Most of the information needed is stored in the <code>parms</code> attribute of the <code>splinetree</code> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">node4coeffs &lt;-<span class="st"> </span><span class="kw"><a href="../reference/treeSummary.html">treeSummary</a></span>(first_tree)[<span class="st">"4"</span>,]$coeffs

### Define age range we want trajectory predicted over
xvals &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">18</span>,<span class="dv">50</span>,<span class="dt">length.out=</span><span class="dv">50</span>)

### Reconstruct basis matrix. 
basisMat &lt;-<span class="st"> </span><span class="kw">bs</span>(xvals, <span class="dt">degree=</span>first_tree$parms$degree, <span class="dt">Boundary.knots =</span> first_tree$parms$boundaryKnots, <span class="dt">knots =</span> first_tree$parms$innerKnots)

### Compute predicted trajectory.
node4preds &lt;-<span class="st"> </span>basisMat%*%<span class="kw">t</span>(node4coeffs)

### Compare automatic plot to reconstructed plot
<span class="kw">require</span>(ggplot2)
## Loading required package: ggplot2
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw"><a href="../reference/plotNode.html">plotNode</a></span>(first_tree, <span class="dv">4</span>, <span class="dt">includeData=</span><span class="ot">FALSE</span>, <span class="dt">estimateIntercept=</span><span class="ot">FALSE</span>)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-13-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/ggplot">ggplot</a></span>()+<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/geom_path">geom_line</a></span>(<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/aes">aes</a></span>(<span class="dt">x=</span>xvals, <span class="dt">y=</span>node4preds, <span class="dt">color=</span><span class="st">"red"</span>, <span class="dt">size=</span><span class="dv">1</span>))+<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/theme">theme</a></span>(<span class="dt">legend.position=</span><span class="st">"none"</span>)+<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/labs">xlab</a></span>(tree$parms$tvar)+<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/labs">ylab</a></span>(tree$parms$yvar)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-13-2.png" width="672"></p>
<p>While plots such as this one rarely need to be constructed by hand, it it useful to get used to working with the information stored in <code>first_tree$parms</code>, as much of this information will tasks to be customized more quickly.</p>
<p>We might also be interested in knowing how well the predicted coefficients for node 4 match the individually projected coefficients for the individuals who fall in node 4. First, note that we can view the individual coefficients for each person in the dataset in <code>first_tree$parms$flat_data</code> under the name <code>Ydata</code>. We can get all of the flattened data corresponding to node 4 with the function <code>getNodeData</code>, and then look at the individual coefficients.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">node4flatdata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getNodeData.html">getNodeData</a></span>(first_tree, <span class="dv">4</span>, <span class="dt">dataType=</span><span class="st">"flat"</span>)
coeffs &lt;-<span class="st"> </span>node4flatdata$Ydata
<span class="kw">head</span>(coeffs)
##              X1        X2        X3
## [1,]  2.7946466  2.604659  2.806965
## [2,] 21.8426066 -9.832694 18.153387
## [3,]  8.5259209 -6.853505  9.949668
## [4,] -7.7502207  1.661613  1.549227
## [5,] -0.3081449  4.770745 10.596560
## [6,] 10.9441035 21.014290 18.235692</code></pre></div>
<p>Right away, we see that there is huge heterogeneity in coefficients among data that was placed into node 4. This suggests that our tree is not yet doing a great job creating homogenous population subgroups. Next, we will see how to customize the tree to potentially improve performance, and then we will talk about metrics for measuring tree performance.</p>
</div>
<div id="controlling-tree-size" class="section level2">
<h2 class="hasAnchor">
<a href="#controlling-tree-size" class="anchor"></a>Controlling Tree Size</h2>
<p>Our first example tree is quite small, and more homogeneity might be obtained in a larger tree. The tree size is due to the default value of the <em>complexity parameter</em> (<code>cp</code>). The <em>complexity parameter</em> is passed by <code>splinetree</code> into the internal call to <code>rpart</code> and specifies a minimum improvement in node purity that must occur in order for the tree to make a split. The default <code>cp</code> value of 0.01 typically helps prevent overly large trees, but in the NLSY example the relationships are fairly weak, and so we might consider lowering this number in order to achieve more homogenous nodes.</p>
<p>We also notice that one of our terminal nodes, which only includes individuals with 12 or more siblings, only has 16 people in it. While it is interesting to see that individuals in our sample with12 or more siblings tend to gain weight much more rapidly than individuals with less than 12 siblings, this finding applies to a very small group and may be unlikely to generalize to a larger population. To avoid forming very small groups that may only be applicable in our sample, we can provide the tree with a minimum node size. We can modify the tree as follows, and the quickly check the tree size (number of terminal nodes).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">second_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data, <span class="dt">minNodeSize=</span><span class="dv">20</span>, <span class="dt">cp=</span><span class="fl">0.001</span>)
<span class="kw"><a href="../reference/treeSize.html">treeSize</a></span>(second_tree)
## [1] 28</code></pre></div>
<p>When we lower the <code>cp</code> to 0.001, the tree has 28 terminal nodes. This tree will be difficult to plot or analyze. Let’s try an in-between <code>cp</code> of 0.005.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">third_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data, <span class="dt">minNodeSize=</span><span class="dv">20</span>, <span class="dt">cp=</span><span class="fl">0.005</span>)
<span class="kw"><a href="../reference/treeSize.html">treeSize</a></span>(third_tree)  
## [1] 6
<span class="kw"><a href="../reference/stPrint.html">stPrint</a></span>(third_tree)
## n= 1000,  
## 
## node), split, n , coefficients 
##       * denotes terminal node
## 
##  1) root, 1000,  ( 4.2565220, 7.366760,  7.648072) 
##    2) HGC_MOTHER&lt; 9.5, 257,  ( 6.5815670, 8.587719,  9.165490) 
##      4) Num_sibs&lt; 8.5, 220,  ( 5.0164670, 8.499161,  8.760898) 
##        8) Age_first_smoke&lt; 14.5, 25,  (-0.6891532, 8.210705,  2.540081)*
##        9) Age_first_smoke&gt;=14.5, 195,  ( 5.7479570, 8.536143,  9.558439)*
##      5) Num_sibs&gt;=8.5, 37,  (15.8875700, 9.114282, 11.571170)*
##    3) HGC_MOTHER&gt;=9.5, 743,  ( 3.4523010, 6.944437,  7.123205) 
##      6) BLACK&lt; 0.5, 518,  ( 3.2739180, 5.904564,  6.831089)*
##      7) BLACK&gt;=0.5, 225,  ( 3.8629780, 9.338454,  7.795720) 
##       14) Age_first_smoke&lt; 13.5, 22,  (11.1772700, 7.404321, 13.892300)*
##       15) Age_first_smoke&gt;=13.5, 203,  ( 3.0702950, 9.548064,  7.135008)*
<span class="kw"><a href="../reference/stPlot.html">stPlot</a></span>(third_tree, <span class="dt">colors =</span> <span class="kw">c</span>(<span class="st">"red"</span>, <span class="st">"green"</span>, <span class="st">"blue"</span>, <span class="st">"cyan"</span>, <span class="st">"magenta"</span>, <span class="st">"grey"</span>))</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
<p>This tree seems reasonably sized; it is small enough to plot and understand, but gives us a little bit more to work with than our first tree. In general, there is no “best”" size for a tree, and so a value for <code>cp</code> should be chosen based off of particular goals. It is also possible to build a large tree and then prune it when plotting for ease of visualization. This is done using the <code>prune</code> function, which is in the <code>rpart</code> package. For example, we can recover the plot above using:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/stPlot.html">stPlot</a></span>(<span class="kw">prune</span>(second_tree, <span class="dt">cp=</span><span class="fl">0.005</span>), <span class="dt">colors =</span> <span class="kw">c</span>(<span class="st">"red"</span>, <span class="st">"green"</span>, <span class="st">"blue"</span>, <span class="st">"cyan"</span>, <span class="st">"magenta"</span>, <span class="st">"grey"</span>))</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-17-1.png" width="672"></p>
</div>
<div id="controlling-the-evaluation-grid" class="section level2">
<h2 class="hasAnchor">
<a href="#controlling-the-evaluation-grid" class="anchor"></a>Controlling the Evaluation Grid</h2>
<p>Another way to customize a tree is to change the grid upon which the projection sum of squares split function is evaluated. This can be done through the <code>nGrid</code> parameter (provides a number of grid points to be placed automatically at quantiles of the time data) or through the <code>gridPoints</code> parameter (provides a list of grid points). Typically, the choice of grid points is not particularly important and will not effect the tree building process. The default is 7 equally spaced grid points. If we increase this to 50 equally spaced grid points, we get a tree that is quite similar to the previous tree. We can see that <code>fourth_tree</code> and <code>third_tree</code> are very similar by prining them out, but we can also use the <code>treeSimilarity</code> function. The <code>treeSimilarity</code> function reports the Adjusted Rand Index (see package <code>mclust</code>) between the clusterings created by the two trees. This is a useful metric because sometimes, due to highly correlated covariates, two trees that appear to split on different variables may actually define very similar population subgroups. A value close to 1 indicates a very similar clustering, and so we see that our two trees are quite similar.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fourth_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data, <span class="dt">minNodeSize=</span><span class="dv">20</span>, <span class="dt">cp=</span><span class="fl">0.005</span>, <span class="dt">nGrid=</span><span class="dv">50</span>)
<span class="kw"><a href="../reference/treeSimilarity.html">treeSimilarity</a></span>(third_tree, fourth_tree)
## [1] 0.802664</code></pre></div>
<p>However, in some rare circumstances, we might change the tree drastically by changing the grid points. For example, if we set <code>gridPoints = c(18)</code>, the splits of the tree will be evaluated using only the value of the smoothed BMI trajectories at age 18. This is basically a univariate regression tree built to age-18 BMIs, but it allows individuals who have no measurement for BMI at age 18 to be included via their smoothed approximations. This tree is much less similar to the original tree.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fifth_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data, <span class="dt">minNodeSize=</span><span class="dv">20</span>, <span class="dt">cp=</span><span class="fl">0.005</span>, <span class="dt">gridPoints=</span><span class="kw">c</span>(<span class="dv">18</span>))
<span class="kw"><a href="../reference/treeSimilarity.html">treeSimilarity</a></span>(third_tree, fifth_tree)
## [1] 0.3284299</code></pre></div>
</div>
<div id="customizing-spline-basis-matrix" class="section level2">
<h2 class="hasAnchor">
<a href="#customizing-spline-basis-matrix" class="anchor"></a>Customizing Spline Basis Matrix</h2>
<p>We can also change the spline basis that is used to build our tree using the parameters <code>degree</code>, <code>knots</code>, <code>df</code>, and <code>intercept</code>. By default, the package builds trees using a cubic spline basis (<code>degree=3</code>) with no internal knots (<code>knots=NULL</code>, df=<code>NULL</code>) and with no intercept (<code>intercept=FALSE</code>). These parameters should be modified when prior knowledge about a dataset provides clues as to what the trajectories may look like in real life.</p>
<p><span class="citation">@clarke2008social</span> report that adult BMIs tend to increase steadily throughout early adulthood and then flatten out in later adulthood. This type can be modeled with a quadratic trajectory (<code>degree=2</code>) or a piecewise linear trajectory (<code>degree=1</code>). If we choose a linear trajectory, we must add an internal knot. We can do this in two ways. One way is to set the <code>df</code> parameter (sets the total number of coefficients) to 2. This will add an internal knot automatically at the median age in our dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linear_tree &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data, <span class="dt">minNodeSize=</span><span class="dv">20</span>, <span class="dt">cp=</span><span class="fl">0.007</span>, <span class="dt">degree=</span><span class="dv">1</span>, <span class="dt">df=</span><span class="dv">2</span>) 
<span class="kw"><a href="../reference/stPlot.html">stPlot</a></span>(linear_tree, <span class="dt">colors=</span><span class="kw">c</span>(<span class="st">"red"</span>, <span class="st">"orange"</span>, <span class="st">"yellow"</span>, <span class="st">"green"</span>, <span class="st">"blue"</span>))</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-20-1.png" width="672"></p>
<p>If we had compelling evidence about the specific age at which trajectories flatten out, we could use the <code>knots</code> parameter to place the internal knot at a different location. When used, the <code>knots</code> parameter is a list of the locations of the internal knots. Note that, if <code>knots</code> is supplied, the <code>df</code> parameter will be ignored. Regardless of the values of <code>knots</code> and <code>df</code>, the boundary knots of the spline basis are always set to the minimum and maximum of the time variable in the data.</p>
<p>Although choosing a higher degree and more internal knots will allow each projected trajectory to more closely approximate the true trajectory, if any individual has less observations than the specifed degrees of freedom, they will be assigned NA coefficients and will be thrown out by <code>rpart</code> during the splitting process. The <code>nlsySample</code> has already been limited to individuals with non-missing BMI data at at least 10 time points, and so as long as we do not exceed 10 degrees of freedom this will not be a problem. Another concern involves the placement of internal knots. If an individual has many observations but all of these observations are clustered together on one side of an internal knot, then the coefficient describing the part of the trajectory on the other side of the knot may be NA or it may take on an extreme value. Therefore, before placing internal knots in the tree, we must ensure that all of our individuals have data on both sides of the internal knot. In the <code>nlsySample</code>, we have already ensured that the range from first observation to last observation of all individuals is at least 20 years to protect from this problem.</p>
<p>As a final customization, we can add an intercept to our tree. When <code>intercept=FALSE</code>, the splits of the tree are made based solely on the shape of the trajectories, while ignoring the level. One downside of no-intercept trees is that they can not be used to predict responses. In order to build a tree that can make BMI predictions, and also for the sake of comparison with our no-intercept tree, we will construct another tree with an intercept. To add an intercept to the linear tree, we must increase the <code>df</code> to 3, because we now need 3 total coefficients (one for the intercept, one for the 1-degree polynomial, and one for the internal knot).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linear_tree_intercept &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data, <span class="dt">minNodeSize=</span><span class="dv">20</span>, <span class="dt">cp=</span><span class="fl">0.007</span>, <span class="dt">degree=</span><span class="dv">1</span>, <span class="dt">df=</span><span class="dv">3</span>, <span class="dt">intercept=</span><span class="ot">TRUE</span>) 
<span class="kw"><a href="../reference/stPlot.html">stPlot</a></span>(linear_tree_intercept)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-21-1.png" width="672"></p>
<p>Looking at the difference between this tree and our previous trees is instructive. Our previous trees did not use <code>SEX</code> as a split variable. This suggests that sex may impact the level of an individual’s BMI but not the change in BMI over time.</p>
</div>
</div>
<div id="prediction-and-evaluation" class="section level1">
<h1 class="hasAnchor">
<a href="#prediction-and-evaluation" class="anchor"></a>Prediction and Evaluation</h1>
<p>Now that we have built a few trees and have seen how to work with them, we might wonder how well the tree actually describes the data. For this, we need measures of tree performance. We will start by considering the performance of <code>linear_tree_intercept</code>. The performance of a tree is slightly easier to understand when there is an intercept because we can talk about quantities such as prediction error. To start, we can make predictions from our tree on the training set and look at how well the predicted BMI values match the actual BMI values. The <code><a href="../reference/predictY.html">predictY()</a></code> function also allows the option of predictions on a distinct test set, and so we could also measure out of sample performance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predictions &lt;-<span class="st"> </span><span class="kw"><a href="../reference/predictY.html">predictY</a></span>(linear_tree_intercept)
<span class="kw">cor</span>(predictions, nlsySample$BMI)
## [1] 0.4201772
<span class="kw">plot</span>(predictions, (predictions-nlsySample$BMI), <span class="dt">xlab=</span><span class="st">"Predicted BMI"</span>, <span class="dt">ylab =</span> <span class="st">"Residual"</span>)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-22-1.png" width="672"></p>
<p>We have far more negative residuals than positive residuals. Our tree does not do well predicting extremely high BMIs. The maximum BMI in the dataset is 59.04, but the maximum predicted BMI is just 32.89. Although several individuals in the sample have extremely large BMIs, no node in the tree predicts these BMIs. This suggests that no subgroup of the population that can be described using only these split variables predicts very high BMIs; to form such a subgroup, we would likely need more covariates, such as an average exercise level or a diet description.</p>
<p>As a metric of our trees performance, we can also compute an <span class="math inline">\(R^2\)</span> measure of the total percentage in BMI that is explained by our tree.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/yR2.html">yR2</a></span>(linear_tree_intercept)
## [1] 0.1764301</code></pre></div>
<p>The <span class="math inline">\(R^2\)</span> value for our tree is relatively low. We already know from above that we are unable to explain extremely high BMIs, and this shortcoming likely holds back the <span class="math inline">\(R^2\)</span> value. We can increase <span class="math inline">\(R^2\)</span> by creating an extremely large tree, but this tree is unlikely to perform well out of sample.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linear_tree_intercept_big &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splineTree.html">splineTree</a></span>(split_formula, tformula, idvar, data, <span class="dt">minNodeSize=</span><span class="dv">5</span>, <span class="dt">cp=</span><span class="fl">0.0001</span>, <span class="dt">degree=</span><span class="dv">1</span>, <span class="dt">df=</span><span class="dv">3</span>, <span class="dt">intercept=</span><span class="ot">TRUE</span>) 
<span class="kw"><a href="../reference/treeSize.html">treeSize</a></span>(linear_tree_intercept_big)
## [1] 120
<span class="kw"><a href="../reference/yR2.html">yR2</a></span>(linear_tree_intercept_big)
## [1] 0.4314036</code></pre></div>
<p>The <code><a href="../reference/yR2.html">yR2()</a></code> function tells us the percentage of variation in actual <code>BMI</code> that our model explains. This includes both the variation explained by the splits in the tree and the variation explained by the relationship with age that is modeled in the trajectories. Another option is to use the <code><a href="../reference/projectedR2.html">projectedR2()</a></code> function, which tells us the percentage of variation in the smoothed <code>BMI</code> trajectories that we explain. For a tree built with an intercept, this seems like a strange choice; why would we care that our tree is great at explaining projected trajectories if the projected trajectories do not explain the actual response?</p>
<p>One advantage of <code><a href="../reference/projectedR2.html">projectedR2()</a></code> is that it takes away the variation explained by the relationship between AGE and BMI. The “total variation” is no longer the total variation of all BMIs around their mean- it is the total variation of all BMIs around the mean trajectory at the appropriate age. Therefore, while performance will appear “worse” under the <code><a href="../reference/projectedR2.html">projectedR2()</a></code> metric, the metric more accurately describes the variation explained by the splits of the tree. Furthermore, <code><a href="../reference/projectedR2.html">projectedR2()</a></code> can be used on intercept trees and no intercept trees alike. On intercept trees, there is the option to include or ignore the intercept coefficient. When the intercept coefficient is ignored, the metric captures the percentage of variation in trajectory shape that is explained by the splits of the tree. When the intercept is included, the performance includes the percentage of variation in starting level that is explained.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/projectedR2.html">projectedR2</a></span>(linear_tree_intercept, <span class="dt">includeIntercept =</span> <span class="ot">TRUE</span>)
##            [,1]
## [1,] 0.06304377
<span class="kw"><a href="../reference/projectedR2.html">projectedR2</a></span>(linear_tree_intercept, <span class="dt">includeIntercept =</span> <span class="ot">FALSE</span>)
##            [,1]
## [1,] 0.03854126
<span class="kw"><a href="../reference/projectedR2.html">projectedR2</a></span>(linear_tree)
##            [,1]
## [1,] 0.05891497</code></pre></div>
<p>These numbers are quite low, which is not wholly surprising. Most of the variation in BMI that can be explained by the available data is explained by AGE. Once the relationship between BMI and AGE is accounted for, without any information about diet or exercise or other habits, there is only a small amount of variation that can be explained by these baseline socioeconomic factors.</p>
<p>In order to understand the <code>projectedR2</code> performance of a tree, it might be useful to compare predicted coefficients and actual coefficients for a certain individual. To do this, we can use the <code><a href="../reference/predictCoeffs.html">predictCoeffs()</a></code> function. If no testset is provided, <code><a href="../reference/predictCoeffs.html">predictCoeffs(tree)</a></code> uses <code>tree$parms$flat_data</code> as the testset, and so the rows of the data structure returned will correspond to rows in <code>tree$parms$flat_data</code>.</p>
<p>Suppose that we were really curious about how our linear intercept tree performed for the individual in our dataset with ID=559. We could plot this individual’s actual BMI data along with their smoothed trajectory and their predicted trajectory. In order to view an individual’s own smoothed trajectory, we need to obtain their individual coefficients and reconstruct the appropriate basis matrix. In order to view their predicted trajectory, we could use <code><a href="../reference/predictCoeffs.html">predictCoeffs()</a></code> and a basis matrix, but we could obtain the same results using the <code><a href="../reference/predictY.html">predictY()</a></code> function. Both methods are shown below for the sake of an instructive example.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">### Get appropriate data
persondata &lt;-<span class="st"> </span>nlsySample[nlsySample$ID==<span class="dv">559</span>,]

### Get the individual coefficients for this individual. Stored in "flat_data". 
personcoeffs &lt;-<span class="st"> </span>linear_tree_intercept$parms$flat_data[linear_tree_intercept$parms$flat_data$ID==<span class="dv">559</span>,]$Ydata

### Get the predicted coefficients for this individual
personpreds &lt;-<span class="st"> </span><span class="kw"><a href="../reference/predictCoeffs.html">predictCoeffs</a></span>(linear_tree_intercept, persondata[<span class="dv">1</span>,])

### Form a basis matrix. We must append a column of 1s because this tree has an intercept.
basisMat &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dv">1</span>, <span class="kw">bs</span>(persondata$AGE, <span class="dt">degree=</span>linear_tree_intercept$parms$degree, <span class="dt">Boundary.knots =</span> linear_tree_intercept$parms$boundaryKnots, <span class="dt">knots =</span> linear_tree_intercept$parms$innerKnots))

### Calculate points along the individual smoothed trajectory and predicted trajectory
smoothed &lt;-<span class="st"> </span>basisMat %*%<span class="st"> </span><span class="kw">t</span>(personcoeffs)
predicted &lt;-<span class="st"> </span>basisMat %*%<span class="st"> </span>personpreds

<span class="kw">plot</span>(BMI~AGE, <span class="dt">data=</span>persondata, <span class="dt">pch=</span><span class="dv">19</span>)
<span class="kw">points</span>(persondata$AGE, smoothed, <span class="dt">type=</span><span class="st">'l'</span>, <span class="dt">col=</span><span class="st">"red"</span>)
<span class="kw">points</span>(persondata$AGE, predicted, <span class="dt">type=</span><span class="st">'l'</span>, <span class="dt">col=</span><span class="st">"blue"</span>)
#### Add the points obtained from "predictY" to show that they match the blue line
<span class="kw">points</span>(persondata$AGE, <span class="kw"><a href="../reference/predictY.html">predictY</a></span>(linear_tree_intercept, persondata), <span class="dt">col=</span><span class="st">"blue"</span>, <span class="dt">pch=</span><span class="dv">19</span>)</code></pre></div>
<p><img src="Tree-Intro_files/figure-html/unnamed-chunk-26-1.png" width="672"> We see from the plot that using <code><a href="../reference/predictCoeffs.html">predictCoeffs()</a></code> and <code><a href="../reference/predictY.html">predictY()</a></code> eventually yield the same predicted trajectory. We also see that, for this particular person, a linear spline basis with one knot was not a good model of their actual BMI trajectory. We also see that their predicted trajectory tends to estimate lower body mass index values than the individual trajectory, echoing the finding above that our model does not seem to predict large BMIs very well.</p>
<div id="conclusion" class="section level2">
<h2 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h2>
<p>In this vignette, we saw how to build a tree and then customize the tree by altering the tree size, the spline basis, and the projection grid. We also saw how to print or plot a spline tree, work with splinetree components by hand, and evaluate a splinetree using <span class="math inline">\(R^2\)</span> metrics. One aspect of our trees that we have yet to address is variable importance. Different trees that we built throughout this vignette included different sets of split variables. Faced with this inconsistency, how do we know which of the split variables contribute most to the portion of varation in BMI trajectory that we are able to explain? To answer this question most accurately, we must use spline forests. For more information, see the <em>Forest Building with SplineTree</em> Vignette.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#building-and-visualizing-trees">Building and Visualizing Trees</a><ul class="nav nav-pills nav-stacked">
<li><a href="#building-our-first-tree">Building our first tree</a></li>
      <li><a href="#viewing-and-visualizing-the-first-tree">Viewing and visualizing the first tree</a></li>
      <li><a href="#controlling-tree-size">Controlling Tree Size</a></li>
      <li><a href="#controlling-the-evaluation-grid">Controlling the Evaluation Grid</a></li>
      <li><a href="#customizing-spline-basis-matrix">Customizing Spline Basis Matrix</a></li>
      </ul>
</li>
      <li>
<a href="#prediction-and-evaluation">Prediction and Evaluation</a><ul class="nav nav-pills nav-stacked">
<li><a href="#conclusion">Conclusion</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Anna Neufeld, Brianna Heggeseth.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
